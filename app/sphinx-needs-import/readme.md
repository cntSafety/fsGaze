### Sphinx Needs JSON → Neo4j cheat sheet

This summarizes the most important fields in `needs.json` and how our importer maps them into the Neo4j graph. Generated by Sphinx with `sphinx_needs` enabled and `needs_build_json = True`. See the Sphinx documentation: [Sphinx docs](https://www.sphinx-doc.org/)

#### Where it comes from
- File: `demoProject/ExpoAssistent/build/html/needs.json`
- Generated by Sphinx build when `sphinx_needs` is active and JSON export is on.
- Config: `demoProject/ExpoAssistent/source/conf.py` (defines `needs_types`, `needs_extra_options`, `needs_build_json = True`).

#### Top-level structure
- `created`, `project`, `current_version`
- `versions` → map keyed by version, each containing:
  - `needs` → all items keyed by their `id`
  - `needs_amount` → count
  - `needs_schema` → JSON Schema for all fields (core/extra/links/backlinks, defaults, descriptions)

#### Per-need fields (most useful)
- Core identity and type
  - `id` (string) → Neo4j: property `id`; used for relationships and cross-linking
  - `title` (string) → Neo4j: property `title`
  - `type` (string, e.g., `req`, `arch`) → Neo4j: node label is capitalizeFirstLetter(type), e.g., `req` → `:Req`, `arch` → `:Arch`; also stored as property `type`
  - `type_name` (string) → Neo4j: property `type_name`
- Documentation context
  - `docname` (string, `.rst` without extension) → not imported (kept in JSON for traceability)
  - `lineno` (int) → not imported
  - `sections` (string[]) → Neo4j: first element saved as property `section` (if present)
  - `section_name` (string) → not imported
- Content and status
  - `content` (string) → Neo4j: property `content`
  - `status` (string or null) → Neo4j: property `status`
  - `tags` (string[]) → Neo4j: property `tags` as comma-separated string
- Custom extras from config (examples in this project)
  - `asil` (string) → Neo4j: property `asil`
  - `sreqtype` (string, e.g., `SR` or `DFA`) → Neo4j: property `sreqtype`
- Links (graph)
  - `links` (string[]) → Neo4j: create `(source)-[:LINKS]->(target)` for each id
  - `links_back` (string[]) → Neo4j: create `(source)-[:LINKS_BACK]->(target)` for each id
- External/service/meta (not imported by default)
  - `external_url`, `url`, `is_external`, `layout`, `style`, `template`, `constraints*`, `created_at`, `updated_at`, etc.

Note: If `type` is missing, importer uses label `:Generic`.

#### Additional cross-graph links
The importer also connects SysML/RequirementUsage nodes to Sphinx Needs requirements by matching a stored `sphinx_needs_id`:
- Pattern:
  - Match `(req:RequirementUsage)-[:links{member:true}]->(ref:ReferenceUsage{name:'sphinx_needs_id'})-[:links{ownedMember:true}]->(lit:LiteralString)`
  - Find the Sphinx Need requirement `(sn:Req {id: lit.value})`
  - Create `(:Req)-[:SNLINK]->(:RequirementUsage)` and the reverse `(:RequirementUsage)-[:SNLINKBACK]->(:Req)`

#### Quick Cypher snippets
- Count all Sphinx Needs nodes:
```cypher
MATCH (n) WHERE n.source = 'sphinx_needs' RETURN count(n);
```
- List Sphinx Needs requirements:
```cypher
MATCH (r:Req) WHERE r.source = 'sphinx_needs' RETURN r LIMIT 25;
```
- Follow Needs links:
```cypher
MATCH (a)-[:LINKS]->(b)
WHERE a.source = 'sphinx_needs' AND b.source = 'sphinx_needs'
RETURN a.id, b.id LIMIT 25;
```
- Filter by `sreqtype`:
```cypher
MATCH (r:Req {source:'sphinx_needs'})
WHERE r.sreqtype IN ['SR','DFA']
RETURN r.id, r.sreqtype;
```
- Join to existing `RequirementUsage` via SNLINK:
```cypher
MATCH (sn:Req)-[:SNLINK]->(ru:RequirementUsage)
RETURN sn.id, ru.name LIMIT 25;
```

#### Why Sphinx Needs is “special” (in brief)
- Strongly-typed, extensible data model for documentation items (needs), not just text.
- First-class graph (forward and reverse links) embedded in docs.
- Self-describing export via JSON Schema for reliable downstream tooling.
- Provenance (docname, line, sections) for traceability back to sources.